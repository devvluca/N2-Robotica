[
    {
        "id": "flow_aspirador",
        "type": "tab",
        "label": "Rob√¥ Aspirador Inteligente",
        "disabled": false,
        "info": "Dashboard para monitoramento do Rob√¥ Aspirador com Aprendizado de Rotas",
        "env": []
    },
    {
        "id": "http_in_aspirador",
        "type": "http in",
        "z": "flow_aspirador",
        "name": "Receber Dados",
        "url": "/aspirador",
        "method": "post",
        "upload": false,
        "skipBodyParsing": false,
        "swaggerDoc": "",
        "x": 140,
        "y": 160,
        "wires": [
            [
                "json_parse"
            ]
        ]
    },
    {
        "id": "json_parse",
        "type": "json",
        "z": "flow_aspirador",
        "name": "",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 290,
        "y": 160,
        "wires": [
            [
                "process_data",
                "http_resp",
                "save_metrics"
            ]
        ]
    },
    {
        "id": "http_resp",
        "type": "http response",
        "z": "flow_aspirador",
        "name": "OK",
        "statusCode": "200",
        "headers": {},
        "x": 450,
        "y": 220,
        "wires": []
    },
    {
        "id": "process_data",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Processar Dados",
        "func": "const d = msg.payload;\nlet txt = '';\nlet fill = 'grey';\n\nswitch(d.type) {\n    case 'simulation_start':\n        txt = `üöÄ EXECU√á√ÉO ${d.execution} INICIADA`;\n        if (d.config && d.config.use_previous_map) {\n            txt += ' (üß† com mapa aprendido)';\n        } else {\n            txt += ' (modo explorat√≥rio)';\n        }\n        fill = 'blue';\n        break;\n        \n    case 'periodic_update':\n        const m = d.metrics;\n        if (m) {\n            txt = `üìä Exec ${d.execution || '?'} | `;\n            txt += `Cobertura: ${(m.coverage_percent || 0).toFixed(1)}% | `;\n            txt += `Energia: ${(m.energy_consumed || 0).toFixed(1)}J | `;\n            txt += `Tempo: ${(m.time_elapsed_s || 0).toFixed(0)}s | `;\n            txt += `Estado: ${m.state || 'N/A'}`;\n            fill = 'green';\n        }\n        break;\n        \n    case 'simulation_end':\n        const s = d.summary;\n        if (s) {\n            txt = `üèÅ EXECU√á√ÉO ${d.execution} FINALIZADA\\n`;\n            txt += `   ‚úì Cobertura: ${(s.coverage_percent || 0).toFixed(1)}%\\n`;\n            txt += `   ‚úì Tempo: ${(s.total_time_s || 0).toFixed(1)}s\\n`;\n            txt += `   ‚úì Energia: ${(s.energy_consumed || 0).toFixed(1)}J\\n`;\n            txt += `   ‚úì Dist√¢ncia: ${(s.distance_traveled || 0).toFixed(1)}m\\n`;\n            txt += `   ‚úì Colis√µes: ${s.collisions || 0}\\n`;\n            txt += `   ‚úì Efici√™ncia: ${(s.efficiency || 0).toFixed(4)} m¬≤/J`;\n            fill = 'blue';\n        }\n        break;\n        \n    case 'comparison':\n        txt = 'üìà COMPARATIVO DE EXECU√á√ïES:\\n';\n        if (d.executions && d.executions.length > 0) {\n            d.executions.forEach(e => {\n                txt += `   Exec ${e.execution}: ${(e.coverage_percent || 0).toFixed(1)}% | `;\n                txt += `${(e.total_time || 0).toFixed(0)}s | `;\n                txt += `${(e.energy || 0).toFixed(1)}J | `;\n                txt += `Efic: ${(e.area_per_energy || 0).toFixed(4)}\\n`;\n            });\n            \n            // Calcular melhoria\n            if (d.executions.length > 1) {\n                const first = d.executions[0];\n                const last = d.executions[d.executions.length - 1];\n                const effImprove = ((last.area_per_energy - first.area_per_energy) / first.area_per_energy * 100).toFixed(1);\n                txt += `\\n   üìä Melhoria de efici√™ncia: ${effImprove}%`;\n            }\n        }\n        fill = 'yellow';\n        break;\n        \n    case 'trajectory_point':\n        // Silencioso - muitos pontos\n        return null;\n        \n    default:\n        txt = JSON.stringify(d);\n}\n\nnode.status({fill: fill, shape: 'dot', text: d.type});\nmsg.payload = txt;\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 160,
        "wires": [
            [
                "debug_aspirador"
            ]
        ]
    },
    {
        "id": "debug_aspirador",
        "type": "debug",
        "z": "flow_aspirador",
        "name": "ü§ñ Aspirador",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 690,
        "y": 160,
        "wires": []
    },
    {
        "id": "save_metrics",
        "type": "function",
        "z": "flow_aspirador",
        "name": "Salvar M√©tricas",
        "func": "// Salvar m√©tricas no contexto do flow\nconst d = msg.payload;\n\nif (d.type === 'simulation_end') {\n    let history = flow.get('execution_history') || [];\n    history.push({\n        execution: d.execution,\n        timestamp: d.timestamp,\n        summary: d.summary\n    });\n    flow.set('execution_history', history);\n    \n    msg.payload = `Execu√ß√£o ${d.execution} salva no hist√≥rico`;\n    return msg;\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 280,
        "wires": [
            [
                "debug_save"
            ]
        ]
    },
    {
        "id": "debug_save",
        "type": "debug",
        "z": "flow_aspirador",
        "name": "üíæ Hist√≥rico",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "x": 690,
        "y": 280,
        "wires": []
    },
    {
        "id": "inject_test_start",
        "type": "inject",
        "z": "flow_aspirador",
        "name": "Teste Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"type\":\"simulation_start\",\"execution\":1,\"config\":{\"width\":2.5,\"height\":2.5,\"use_previous_map\":false}}",
        "payloadType": "json",
        "x": 140,
        "y": 60,
        "wires": [
            [
                "process_data"
            ]
        ]
    },
    {
        "id": "inject_test_update",
        "type": "inject",
        "z": "flow_aspirador",
        "name": "Teste Update",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"type\":\"periodic_update\",\"execution\":1,\"metrics\":{\"coverage_percent\":45.5,\"energy_consumed\":12.34,\"time_elapsed_s\":30,\"state\":\"SWEEPING\"}}",
        "payloadType": "json",
        "x": 150,
        "y": 340,
        "wires": [
            [
                "process_data"
            ]
        ]
    },
    {
        "id": "inject_test_end",
        "type": "inject",
        "z": "flow_aspirador",
        "name": "Teste End",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"type\":\"simulation_end\",\"execution\":1,\"summary\":{\"coverage_percent\":92.5,\"total_time_s\":85,\"energy_consumed\":45.67,\"distance_traveled\":38.5,\"collisions\":12,\"efficiency\":0.0234}}",
        "payloadType": "json",
        "x": 140,
        "y": 400,
        "wires": [
            [
                "process_data",
                "save_metrics"
            ]
        ]
    },
    {
        "id": "inject_test_comparison",
        "type": "inject",
        "z": "flow_aspirador",
        "name": "Teste Comparativo",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "{\"type\":\"comparison\",\"executions\":[{\"execution\":1,\"coverage_percent\":85.4,\"total_time\":60,\"energy\":154.64,\"area_per_energy\":0.0244},{\"execution\":2,\"coverage_percent\":86.8,\"total_time\":60,\"energy\":163.29,\"area_per_energy\":0.0232},{\"execution\":3,\"coverage_percent\":86.7,\"total_time\":60,\"energy\":141.38,\"area_per_energy\":0.0263}]}",
        "payloadType": "json",
        "x": 170,
        "y": 460,
        "wires": [
            [
                "process_data"
            ]
        ]
    },
    {
        "id": "comment_info",
        "type": "comment",
        "z": "flow_aspirador",
        "name": "üìã Rob√¥ Aspirador Inteligente com Aprendizado",
        "info": "## Rob√¥ Aspirador Inteligente\n\n### Funcionalidades:\n- Recebe dados em tempo real da simula√ß√£o PyBullet\n- Exibe cobertura, energia, tempo e estado\n- Armazena hist√≥rico de execu√ß√µes\n- Compara melhorias entre execu√ß√µes\n\n### Tipos de mensagens:\n- `simulation_start`: In√≠cio de execu√ß√£o\n- `periodic_update`: Atualiza√ß√£o a cada 2s\n- `simulation_end`: Fim de execu√ß√£o com resumo\n- `comparison`: Comparativo de todas execu√ß√µes\n\n### Endpoint:\nPOST /aspirador",
        "x": 230,
        "y": 520,
        "wires": []
    }
]
